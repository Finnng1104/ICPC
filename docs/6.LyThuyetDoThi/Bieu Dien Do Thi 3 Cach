# ğŸ“˜ 3 CÃCH BIá»‚U DIá»„N Äá»’ THá»Š TRONG Láº¬P TRÃŒNH THI Äáº¤U
# --------------------------------------------------
# Vá»›i Ä‘á»“ thá»‹ cÃ³ N Ä‘á»‰nh (tá»« 0 Ä‘áº¿n N-1), M cáº¡nh.
# Giáº£ sá»­ cáº¡nh cÃ³ trá»ng sá»‘ (cÃ³ thá»ƒ = 1 náº¿u khÃ´ng trá»ng sá»‘)

N = 4
edges = [
    (0, 1, 2),  # cáº¡nh tá»« 0 â†’ 1 trá»ng sá»‘ 2
    (0, 2, 4),
    (1, 2, 1),
    (1, 3, 7),
    (2, 3, 3)
]

# ===================================================
# 1ï¸âƒ£ DANH SÃCH Ká»€ (Adjacency List)
# Tá»‘t cho duyá»‡t BFS/DFS, Ä‘á»“ thá»‹ thÆ°a
adj_list = [[] for _ in range(N)]
for u, v, w in edges:
    adj_list[u].append((v, w))  # Náº¿u vÃ´ hÆ°á»›ng: thÃªm cáº£ (v â†’ u)

print("\nğŸ“‹ Danh sÃ¡ch ká»:")
for u in range(N):
    print(f"{u} â†’ {adj_list[u]}")

# ===================================================
# 2ï¸âƒ£ MA TRáº¬N Ká»€ (Adjacency Matrix)
# Tá»‘t cho kiá»ƒm tra tá»“n táº¡i cáº¡nh, Ä‘á»“ thá»‹ nhá»
adj_matrix = [[0]*N for _ in range(N)]
for u, v, w in edges:
    adj_matrix[u][v] = w

print("\nğŸ§® Ma tráº­n ká»:")
for row in adj_matrix:
    print(row)

# ===================================================
# 3ï¸âƒ£ DANH SÃCH Cáº NH (Edge List)
# Tá»‘t cho Kruskal, Bellman-Ford
edge_list = list(edges)  # Ä‘Æ¡n giáº£n lÃ  giá»¯ nguyÃªn danh sÃ¡ch cáº¡nh

print("\nğŸ“ Danh sÃ¡ch cáº¡nh:")
for u, v, w in edge_list:
    print(f"{u} â†’ {v} (trá»ng sá»‘ {w})")

# ===================================================
# ğŸ§  Gá»¢I Ã DÃ™NG
# - Adjacency List: BFS, DFS, Dijkstra
# - Adjacency Matrix: Floyd-Warshall, bÃ i nhá»
# - Edge List: Kruskal, Bellman-Ford

# ========= BÃ€I TOÃN ICPC MINH Há»ŒA =========

# ========= BÃ€I 1: ÄÆ¯á»œNG ÄI NGáº®N NHáº¤T (DANH SÃCH Ká»€) =========
"""
â“ Äá» bÃ i: Cho Ä‘á»“ thá»‹ cÃ³ hÆ°á»›ng N Ä‘á»‰nh, M cáº¡nh. Má»—i cáº¡nh cÃ³ trá»ng sá»‘ dÆ°Æ¡ng.
TÃ¬m Ä‘Æ°á»ng Ä‘i ngáº¯n nháº¥t tá»« Ä‘á»‰nh 0 Ä‘áº¿n Ä‘á»‰nh N-1.

ğŸ” INPUT:
- DÃ²ng 1: N M
- M dÃ²ng tiáº¿p: u v w

ğŸ” OUTPUT:
- Khoáº£ng cÃ¡ch ngáº¯n nháº¥t tá»« 0 Ä‘áº¿n N-1
- ÄÆ°á»ng Ä‘i (náº¿u cÃ³)

ğŸ’¡ PhÃ¢n tÃ­ch:
- Äá»“ thá»‹ cÃ³ hÆ°á»›ng + trá»ng sá»‘ dÆ°Æ¡ng â†’ Dijkstra
- N â‰¤ 10^5 â†’ dÃ¹ng danh sÃ¡ch ká» Ä‘á»ƒ tiáº¿t kiá»‡m bá»™ nhá»›
- Cáº§n lÆ°u Ä‘Æ°á»ng Ä‘i â†’ thÃªm máº£ng parent[]
"""

def solve_shortest_path():
    # Nháº­p dá»¯ liá»‡u
    n, m = map(int, input().split())
    adj = [[] for _ in range(n)]
    for _ in range(m):
        u, v, w = map(int, input().split())
        adj[u].append((v, w))
    
    # Dijkstra vá»›i danh sÃ¡ch ká»
    import heapq
    INF = int(1e9)
    dist = [INF]*n
    parent = [-1]*n
    dist[0] = 0
    pq = [(0, 0)]
    
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]: continue
        for v, w in adj[u]:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                parent[v] = u
                heapq.heappush(pq, (dist[v], v))
    
    # In káº¿t quáº£
    if dist[n-1] == INF:
        print(-1)  # KhÃ´ng cÃ³ Ä‘Æ°á»ng Ä‘i
    else:
        print(dist[n-1])
        # In Ä‘Æ°á»ng Ä‘i
        path = []
        v = n-1
        while v != -1:
            path.append(v)
            v = parent[v]
        print("->".join(map(str, reversed(path))))

# ========= BÃ€I 2: CHU TRÃŒNH HAMILTON (MA TRáº¬N Ká»€) =========
"""
â“ Äá» bÃ i: Cho Ä‘á»“ thá»‹ vÃ´ hÆ°á»›ng N Ä‘á»‰nh. Kiá»ƒm tra xem cÃ³ tá»“n táº¡i
chu trÃ¬nh Hamilton (Ä‘i qua má»—i Ä‘á»‰nh Ä‘Ãºng 1 láº§n) khÃ´ng?

ğŸ” INPUT:
- DÃ²ng 1: N
- N dÃ²ng tiáº¿p: ma tráº­n ká» (1 náº¿u cÃ³ cáº¡nh, 0 náº¿u khÃ´ng)

ğŸ” OUTPUT:
- YES náº¿u cÃ³ chu trÃ¬nh Hamilton
- NO náº¿u khÃ´ng cÃ³

ğŸ’¡ PhÃ¢n tÃ­ch:
- N â‰¤ 20 â†’ dÃ¹ng ma tráº­n ká» Ä‘á»ƒ kiá»ƒm tra cáº¡nh nhanh
- Quay lui + nhÃ¡nh cáº­n Ä‘á»ƒ tÃ¬m chu trÃ¬nh
- LÆ°u tráº¡ng thÃ¡i Ä‘Ã£ thÄƒm báº±ng bitmask
"""

def solve_hamilton_cycle():
    # Nháº­p dá»¯ liá»‡u
    n = int(input())
    adj = [list(map(int, input().split())) for _ in range(n)]
    
    # Quay lui tÃ¬m chu trÃ¬nh
    def backtrack(pos, visited, count):
        if count == n:
            # Kiá»ƒm tra cÃ³ cáº¡nh vá» Ä‘á»‰nh 0 khÃ´ng
            return adj[pos][0] == 1
        
        for next_pos in range(n):
            if not (visited & (1 << next_pos)) and adj[pos][next_pos]:
                if backtrack(next_pos, visited | (1 << next_pos), count + 1):
                    return True
        return False
    
    # Báº¯t Ä‘áº§u tá»« Ä‘á»‰nh 0
    visited = 1  # bitmask: Ä‘á»‰nh 0 Ä‘Ã£ thÄƒm
    print("YES" if backtrack(0, visited, 1) else "NO")

# ========= BÃ€I 3: CÃ‚Y KHUNG NHá» NHáº¤T (DANH SÃCH Cáº NH) =========
"""
â“ Äá» bÃ i: Cho Ä‘á»“ thá»‹ vÃ´ hÆ°á»›ng N Ä‘á»‰nh, M cáº¡nh. Má»—i cáº¡nh cÃ³ trá»ng sá»‘.
TÃ¬m cÃ¢y khung nhá» nháº¥t vá»›i Ä‘iá»u kiá»‡n: cÃ³ Ä‘Ãºng K cáº¡nh mÃ u Ä‘á».

ğŸ” INPUT:
- DÃ²ng 1: N M K
- M dÃ²ng tiáº¿p: u v w c (c=1 náº¿u cáº¡nh Ä‘á», c=0 náº¿u cáº¡nh xanh)

ğŸ” OUTPUT:
- Tá»•ng trá»ng sá»‘ cÃ¢y khung nhá» nháº¥t thá»a mÃ£n
- -1 náº¿u khÃ´ng tá»“n táº¡i

ğŸ’¡ PhÃ¢n tÃ­ch:
- Cáº§n sáº¯p xáº¿p cáº¡nh â†’ dÃ¹ng danh sÃ¡ch cáº¡nh
- Kruskal vá»›i Ä‘iá»u kiá»‡n sá»‘ cáº¡nh Ä‘á»
- DSU Ä‘á»ƒ kiá»ƒm tra chu trÃ¬nh
"""

def solve_mst_with_constraint():
    # Nháº­p dá»¯ liá»‡u
    n, m, k = map(int, input().split())
    edges = []
    for _ in range(m):
        u, v, w, c = map(int, input().split())
        edges.append((w, c, u-1, v-1))
    
    # Sáº¯p xáº¿p cáº¡nh theo trá»ng sá»‘
    edges.sort()
    
    # DSU
    class DSU:
        def __init__(self, n):
            self.parent = list(range(n))
            self.rank = [0]*n
        
        def find(self, x):
            if self.parent[x] != x:
                self.parent[x] = self.find(self.parent[x])
            return self.parent[x]
        
        def union(self, x, y):
            px, py = self.find(x), self.find(y)
            if px == py: return False
            if self.rank[px] < self.rank[py]:
                px, py = py, px
            self.parent[py] = px
            if self.rank[px] == self.rank[py]:
                self.rank[px] += 1
            return True
    
    # Thá»­ táº¥t cáº£ sá»‘ cáº¡nh Ä‘á» cÃ³ thá»ƒ
    def try_mst(target_red):
        dsu = DSU(n)
        total = 0
        red_count = 0
        
        # Æ¯u tiÃªn cáº¡nh Ä‘á» náº¿u cáº§n thÃªm
        if target_red > 0:
            for w, c, u, v in edges:
                if c == 1 and dsu.union(u, v):
                    total += w
                    red_count += 1
                    if red_count == target_red:
                        break
        
        # ThÃªm cÃ¡c cáº¡nh cÃ²n láº¡i
        for w, c, u, v in edges:
            if dsu.union(u, v):
                total += w
                if c == 1:
                    red_count += 1
        
        # Kiá»ƒm tra Ä‘iá»u kiá»‡n
        if red_count == k and all(dsu.find(0) == dsu.find(i) for i in range(n)):
            return total
        return float('inf')
    
    # TÃ¬m káº¿t quáº£ tá»‘t nháº¥t
    result = min(try_mst(r) for r in range(k+1))
    print(result if result != float('inf') else -1)

# ========= DEMO =========
if __name__ == "__main__":
    print("\n=== Demo cÃ¡c bÃ i toÃ¡n ICPC ===")
    
    print("\n1. ÄÆ°á»ng Ä‘i ngáº¯n nháº¥t (Dijkstra):")
    test_input = """5 6
0 1 2
0 2 4
1 2 1
1 3 7
2 3 3
3 4 1"""
    import sys
    from io import StringIO
    sys.stdin = StringIO(test_input)
    solve_shortest_path()
    
    print("\n2. Chu trÃ¬nh Hamilton:")
    test_input = """4
0 1 1 1
1 0 1 1
1 1 0 1
1 1 1 0"""
    sys.stdin = StringIO(test_input)
    solve_hamilton_cycle()
    
    print("\n3. MST vá»›i rÃ ng buá»™c:")
    test_input = """4 5 2
1 2 2 1
1 3 3 0
2 3 1 1
2 4 4 0
3 4 5 1"""
    sys.stdin = StringIO(test_input)
    solve_mst_with_constraint()
    
    print("\nâœ… ÄÃ£ demo 3 bÃ i toÃ¡n ICPC vá»›i cÃ¡c cÃ¡ch biá»ƒu diá»…n Ä‘á»“ thá»‹ khÃ¡c nhau.")
    print("ğŸ’¡ Má»—i cÃ¡ch biá»ƒu diá»…n phÃ¹ há»£p vá»›i má»™t loáº¡i bÃ i toÃ¡n cá»¥ thá»ƒ!")
