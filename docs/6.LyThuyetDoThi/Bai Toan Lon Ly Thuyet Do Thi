# üìå B√ÄI TO√ÅN L·ªöN T·ªîNG QU√ÅT V·ªÄ L√ù THUY·∫æT ƒê·ªí TH·ªä
# ============================================
"""
L√Ω thuy·∫øt ƒë·ªì th·ªã l√† m·ªôt ch·ªß ƒë·ªÅ quan tr·ªçng trong ICPC v·ªõi nhi·ªÅu ·ª©ng d·ª•ng th·ª±c t·∫ø:

1. C√°c d·∫°ng b√†i ph·ªï bi·∫øn:
   - ƒê∆∞·ªùng ƒëi ng·∫Øn nh·∫•t (Dijkstra, Floyd-Warshall)
   - C√¢y khung nh·ªè nh·∫•t (Kruskal, Prim)
   - Lu·ªìng c·ª±c ƒë·∫°i (Ford-Fulkerson, Dinic)
   - Th√†nh ph·∫ßn li√™n th√¥ng (DFS, BFS)
   - Chu tr√¨nh Euler/Hamilton

2. ·ª®ng d·ª•ng th·ª±c t·∫ø:
   - T√¨m ƒë∆∞·ªùng ƒëi t·ªëi ∆∞u (GPS, b·∫£n ƒë·ªì)
   - Thi·∫øt k·∫ø m·∫°ng (c√¢y khung, lu·ªìng)
   - Ph√¢n t√≠ch m·∫°ng x√£ h·ªôi
   - Game AI (t√¨m ƒë∆∞·ªùng, tr√≤ ch∆°i)
   - L·∫≠p l·ªãch v√† t·ªëi ∆∞u h√≥a

3. K·ªπ thu·∫≠t quan tr·ªçng:
   - Bi·ªÉu di·ªÖn ƒë·ªì th·ªã (ma tr·∫≠n k·ªÅ, danh s√°ch k·ªÅ)
   - Duy·ªát ƒë·ªì th·ªã (DFS, BFS)
   - Quy ho·∫°ch ƒë·ªông tr√™n ƒë·ªì th·ªã
   - X·ª≠ l√Ω ƒë·ªì th·ªã c√≥ h∆∞·ªõng/v√¥ h∆∞·ªõng
   - T·ªëi ∆∞u h√≥a thu·∫≠t to√°n
"""

# ========= B√ÄI TO√ÅN 1: ƒê∆Ø·ªúNG ƒêI NG·∫ÆN NH·∫§T (DIJKSTRA) =========
"""
‚ùì ƒê·ªÅ b√†i: ƒê∆∞·ªùng ƒëi ng·∫Øn nh·∫•t trong ƒë·ªì th·ªã c√≥ h∆∞·ªõng v√† tr·ªçng s·ªë.
B·∫°n ƒë∆∞·ª£c cho m·ªôt ƒë·ªì th·ªã c√≥ N ƒë·ªânh v√† M c·∫°nh. M·ªói c·∫°nh t·ª´ u ƒë·∫øn v c√≥ tr·ªçng s·ªë w.
T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t t·ª´ ƒë·ªânh 1 ƒë·∫øn t·∫•t c·∫£ c√°c ƒë·ªânh c√≤n l·∫°i.

üîç INPUT:
- D√≤ng 1: N M
- M d√≤ng ti·∫øp: u v w

üîé OUTPUT:
- D√≤ng duy nh·∫•t g·ªìm N s·ªë: kho·∫£ng c√°ch ng·∫Øn nh·∫•t t·ª´ ƒë·ªânh 1 ƒë·∫øn c√°c ƒë·ªânh

‚ñ∂ V√≠ d·ª•:
Input:
5 6
1 2 2
1 3 4
2 3 1
2 4 7
3 5 3
4 5 1
Output:
0 2 3 9 6

üí° Ph√¢n t√≠ch:
1. ƒê·ªì th·ªã c√≥ h∆∞·ªõng + tr·ªçng s·ªë kh√¥ng √¢m ‚Üí d√πng Dijkstra
2. C·∫ßn l∆∞u ƒë∆∞·ªùng ƒëi ‚Üí th√™m m·∫£ng parent[]
3. C√≥ th·ªÉ c√≥ nhi·ªÅu test case ‚Üí reset bi·∫øn
4. Gi·ªõi h·∫°n N ‚â§ 10^5 ‚Üí d√πng danh s√°ch k·ªÅ
"""

import heapq

def solve_dijkstra():
    # ===== 1. Nh·∫≠p d·ªØ li·ªáu =====
    n, m = map(int, input().split())
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u-1].append((v-1, w))
    
    # ===== 2. Kh·ªüi t·∫°o =====
    INF = int(1e9)
    dist = [INF]*n
    parent = [-1]*n  # L∆∞u ƒë∆∞·ªùng ƒëi
    dist[0] = 0
    pq = [(0, 0)]
    
    # ===== 3. Dijkstra =====
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]: continue
        
        for v, w in graph[u]:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                parent[v] = u  # L∆∞u node cha
                heapq.heappush(pq, (dist[v], v))
    
    # ===== 4. In k·∫øt qu·∫£ =====
    print(" ".join(map(str, dist)))
    
    # In ƒë∆∞·ªùng ƒëi t·ª´ 1 ƒë·∫øn n (n·∫øu c·∫ßn)
    if parent[n-1] != -1:
        path = []
        v = n-1
        while v != -1:
            path.append(v+1)
            v = parent[v]
        print("ƒê∆∞·ªùng ƒëi:", "->".join(map(str, reversed(path))))

# ========= B√ÄI TO√ÅN 2: C√ÇY KHUNG NH·ªé NH·∫§T (KRUSKAL) =========
"""
‚ùì ƒê·ªÅ b√†i: Cho ƒë·ªì th·ªã v√¥ h∆∞·ªõng c√≥ tr·ªçng s·ªë, t√¨m c√¢y khung nh·ªè nh·∫•t.

üîç INPUT:
- D√≤ng 1: N M
- M d√≤ng ti·∫øp: u v w

üîé OUTPUT:
- T·ªïng tr·ªçng s·ªë c√¢y khung nh·ªè nh·∫•t

‚ñ∂ V√≠ d·ª•:
Input:
4 5
1 2 2
1 3 3
2 3 1
2 4 4
3 4 5
Output:
7

üí° Ph√¢n t√≠ch:
1. ƒê·ªì th·ªã v√¥ h∆∞·ªõng ‚Üí d√πng Kruskal
2. C·∫ßn DSU ƒë·ªÉ ki·ªÉm tra chu tr√¨nh
3. S·∫Øp x·∫øp c·∫°nh theo tr·ªçng s·ªë
4. Th√™m c·∫°nh n·∫øu kh√¥ng t·∫°o chu tr√¨nh
"""

class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0]*n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py: return False
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True

def solve_kruskal():
    # ===== 1. Nh·∫≠p d·ªØ li·ªáu =====
    n, m = map(int, input().split())
    edges = []
    
    for _ in range(m):
        u, v, w = map(int, input().split())
        edges.append((w, u-1, v-1))
    
    # ===== 2. Kruskal =====
    edges.sort()  # S·∫Øp x·∫øp theo tr·ªçng s·ªë
    dsu = DSU(n)
    total = 0
    mst_edges = []
    
    for w, u, v in edges:
        if dsu.union(u, v):
            total += w
            mst_edges.append((u+1, v+1, w))
    
    # ===== 3. In k·∫øt qu·∫£ =====
    print("T·ªïng tr·ªçng s·ªë MST:", total)
    print("C√°c c·∫°nh trong MST:")
    for u, v, w in mst_edges:
        print(f"{u} - {v}: {w}")

# ========= B√ÄI TO√ÅN 3: LU·ªíNG C·ª∞C ƒê·∫†I (FORD-FULKERSON) =========
"""
‚ùì ƒê·ªÅ b√†i: Cho m·∫°ng v·ªõi ngu·ªìn s v√† ƒë√≠ch t, t√¨m lu·ªìng c·ª±c ƒë·∫°i.

üîç INPUT:
- D√≤ng 1: N M s t
- M d√≤ng ti·∫øp: u v c

üîé OUTPUT:
- Gi√° tr·ªã lu·ªìng c·ª±c ƒë·∫°i
- Ma tr·∫≠n lu·ªìng

‚ñ∂ V√≠ d·ª•:
Input:
4 5 1 4
1 2 3
1 3 2
2 3 1
2 4 2
3 4 3
Output:
4
0 2 2 0
0 0 1 1
0 0 0 2
0 0 0 0

üí° Ph√¢n t√≠ch:
1. M·∫°ng c√≥ h∆∞·ªõng ‚Üí d√πng Ford-Fulkerson
2. C·∫ßn ma tr·∫≠n c·∫°nh v√† lu·ªìng
3. T√¨m ƒë∆∞·ªùng tƒÉng lu·ªìng b·∫±ng DFS
4. C·∫≠p nh·∫≠t lu·ªìng v√† c·∫°nh ng∆∞·ª£c
"""

def solve_max_flow():
    # ===== 1. Nh·∫≠p d·ªØ li·ªáu =====
    n, m, s, t = map(int, input().split())
    s, t = s-1, t-1
    cap = [[0]*n for _ in range(n)]
    flow = [[0]*n for _ in range(n)]
    
    for _ in range(m):
        u, v, c = map(int, input().split())
        cap[u-1][v-1] = c
    
    # ===== 2. Ford-Fulkerson =====
    def dfs(u, t, visited, min_flow):
        if u == t: return min_flow
        visited[u] = True
        
        for v in range(n):
            if not visited[v] and cap[u][v] - flow[u][v] > 0:
                f = dfs(v, t, visited, min(min_flow, cap[u][v] - flow[u][v]))
                if f > 0:
                    flow[u][v] += f
                    flow[v][u] -= f
                    return f
        return 0
    
    # ===== 3. T√¨m lu·ªìng c·ª±c ƒë·∫°i =====
    max_flow = 0
    while True:
        visited = [False]*n
        f = dfs(s, t, visited, float('inf'))
        if f == 0: break
        max_flow += f
    
    # ===== 4. In k·∫øt qu·∫£ =====
    print("Lu·ªìng c·ª±c ƒë·∫°i:", max_flow)
    print("Ma tr·∫≠n lu·ªìng:")
    for row in flow:
        print(*row)

# ========= B√ÄI T·∫¨P TH·ª∞C H√ÄNH =========
"""
1. B√†i t·∫≠p c∆° b·∫£n:
   - T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t v·ªõi r√†ng bu·ªôc
   - T√¨m c√¢y khung nh·ªè nh·∫•t v·ªõi ƒëi·ªÅu ki·ªán
   - T√¨m lu·ªìng c·ª±c ƒë·∫°i v·ªõi chi ph√≠ t·ªëi thi·ªÉu

2. B√†i t·∫≠p n√¢ng cao:
   - ƒê∆∞·ªùng ƒëi ng·∫Øn nh·∫•t v·ªõi k c·∫°nh
   - C√¢y khung nh·ªè nh·∫•t v·ªõi k c·∫°nh c·ªë ƒë·ªãnh
   - Lu·ªìng c·ª±c ƒë·∫°i v·ªõi nhi·ªÅu ngu·ªìn/ƒë√≠ch

3. ·ª®ng d·ª•ng th·ª±c t·∫ø:
   - Thi·∫øt k·∫ø m·∫°ng m√°y t√≠nh
   - L·∫≠p l·ªãch s·∫£n xu·∫•t
   - Ph√¢n t√≠ch m·∫°ng x√£ h·ªôi
   - Game AI v√† pathfinding
"""

# ========= DEMO =========
if __name__ == "__main__":
    print("\n=== Demo c√°c thu·∫≠t to√°n ƒë·ªì th·ªã ===")
    
    print("\n1. Dijkstra - ƒê∆∞·ªùng ƒëi ng·∫Øn nh·∫•t:")
    # Test case m·∫´u
    test_input = """5 6
1 2 2
1 3 4
2 3 1
2 4 7
3 5 3
4 5 1"""
    import sys
    from io import StringIO
    sys.stdin = StringIO(test_input)
    solve_dijkstra()
    
    print("\n2. Kruskal - C√¢y khung nh·ªè nh·∫•t:")
    test_input = """4 5
1 2 2
1 3 3
2 3 1
2 4 4
3 4 5"""
    sys.stdin = StringIO(test_input)
    solve_kruskal()
    
    print("\n3. Ford-Fulkerson - Lu·ªìng c·ª±c ƒë·∫°i:")
    test_input = """4 5 1 4
1 2 3
1 3 2
2 3 1
2 4 2
3 4 3"""
    sys.stdin = StringIO(test_input)
    solve_max_flow()
    
  
