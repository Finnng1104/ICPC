# üìö T·ªîNG H·ª¢P 4 THU·∫¨T TO√ÅN T√åM ƒê∆Ø·ªúNG TRONG ƒê·ªí TH·ªä
# ===============================================
"""
B·ªën thu·∫≠t to√°n t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t ph·ªï bi·∫øn trong ICPC:

1. Dijkstra:
   - ƒêi·ªÅu ki·ªán: Tr·ªçng s·ªë kh√¥ng √¢m
   - ƒê·ªô ph·ª©c t·∫°p: O((V+E)logV) v·ªõi heap
   - ·ª®ng d·ª•ng: GPS, routing, game AI

2. Floyd-Warshall:
   - ƒêi·ªÅu ki·ªán: ƒê·ªì th·ªã nh·ªè (V ‚â§ 500)
   - ƒê·ªô ph·ª©c t·∫°p: O(V¬≥)
   - ·ª®ng d·ª•ng: T√¨m ƒë∆∞·ªùng ng·∫Øn nh·∫•t m·ªçi c·∫∑p

3. Bellman-Ford:
   - ƒêi·ªÅu ki·ªán: C√≥ th·ªÉ c√≥ tr·ªçng s·ªë √¢m
   - ƒê·ªô ph·ª©c t·∫°p: O(VE)
   - ·ª®ng d·ª•ng: Ph√°t hi·ªán chu tr√¨nh √¢m

4. BFS:
   - ƒêi·ªÅu ki·ªán: ƒê·ªì th·ªã kh√¥ng tr·ªçng s·ªë
   - ƒê·ªô ph·ª©c t·∫°p: O(V+E)
   - ·ª®ng d·ª•ng: Maze solver, web crawling
"""

import heapq
from collections import deque

# ========== DIJKSTRA ==========
"""
‚ùì ƒê·ªÅ b√†i: Cho ƒë·ªì th·ªã c√≥ h∆∞·ªõng N ƒë·ªânh, M c·∫°nh. M·ªói c·∫°nh c√≥ tr·ªçng s·ªë kh√¥ng √¢m.
T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t t·ª´ ƒë·ªânh 1 ƒë·∫øn t·∫•t c·∫£ c√°c ƒë·ªânh c√≤n l·∫°i.

üîç INPUT:
- D√≤ng 1: N M
- M d√≤ng ti·∫øp: u v w

üîé OUTPUT:
- N s·ªë: kho·∫£ng c√°ch ng·∫Øn nh·∫•t t·ª´ ƒë·ªânh 1

üí° Ph√¢n t√≠ch:
1. ƒê·ªì th·ªã c√≥ h∆∞·ªõng + tr·ªçng s·ªë kh√¥ng √¢m ‚Üí Dijkstra
2. D√πng heap ƒë·ªÉ t·ªëi ∆∞u th·ªùi gian
3. L∆∞u ƒë∆∞·ªùng ƒëi b·∫±ng m·∫£ng parent[]
4. X·ª≠ l√Ω tr∆∞·ªùng h·ª£p kh√¥ng c√≥ ƒë∆∞·ªùng ƒëi
"""

def solve_dijkstra():
    # Nh·∫≠p d·ªØ li·ªáu
    n, m = map(int, input().split())
    adj = [[] for _ in range(n)]  # Danh s√°ch k·ªÅ
    for _ in range(m):
        u, v, w = map(int, input().split())
        adj[u-1].append((v-1, w))
    
    # Dijkstra v·ªõi heap
    INF = int(1e9)
    dist = [INF]*n
    parent = [-1]*n  # L∆∞u ƒë∆∞·ªùng ƒëi
    dist[0] = 0
    pq = [(0, 0)]
    
    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]: continue
        
        for v, w in adj[u]:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                parent[v] = u
                heapq.heappush(pq, (dist[v], v))
    
    # In k·∫øt qu·∫£
    print("Kho·∫£ng c√°ch:", *dist)
    
    # In ƒë∆∞·ªùng ƒëi t·ª´ 1 ƒë·∫øn n (n·∫øu c·∫ßn)
    if parent[n-1] != -1:
        path = []
        v = n-1
        while v != -1:
            path.append(v+1)
            v = parent[v]
        print("ƒê∆∞·ªùng ƒëi:", "->".join(map(str, reversed(path))))

# ========== FLOYD-WARSHALL ==========
"""
‚ùì ƒê·ªÅ b√†i: Cho ƒë·ªì th·ªã c√≥ h∆∞·ªõng N ƒë·ªânh, M c·∫°nh. T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t
gi·ªØa m·ªçi c·∫∑p ƒë·ªânh.

üîç INPUT:
- D√≤ng 1: N M
- M d√≤ng ti·∫øp: u v w

üîé OUTPUT:
- Ma tr·∫≠n NxN: kho·∫£ng c√°ch ng·∫Øn nh·∫•t gi·ªØa m·ªçi c·∫∑p

üí° Ph√¢n t√≠ch:
1. N ‚â§ 500 ‚Üí d√πng Floyd-Warshall
2. C√≥ th·ªÉ ph√°t hi·ªán chu tr√¨nh √¢m
3. T·ªëi ∆∞u b·ªô nh·ªõ v·ªõi ma tr·∫≠n k·ªÅ
4. C√≥ th·ªÉ l∆∞u ƒë∆∞·ªùng ƒëi b·∫±ng m·∫£ng next[][]
"""

def solve_floyd_warshall():
    # Nh·∫≠p d·ªØ li·ªáu
    n, m = map(int, input().split())
    INF = int(1e9)
    dist = [[INF]*n for _ in range(n)]
    next_hop = [[-1]*n for _ in range(n)]  # L∆∞u ƒë∆∞·ªùng ƒëi
    
    # Kh·ªüi t·∫°o
    for i in range(n):
        dist[i][i] = 0
    for _ in range(m):
        u, v, w = map(int, input().split())
        dist[u-1][v-1] = w
        next_hop[u-1][v-1] = v-1
    
    # Floyd-Warshall
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    next_hop[i][j] = next_hop[i][k]
    
    # Ki·ªÉm tra chu tr√¨nh √¢m
    has_negative_cycle = False
    for i in range(n):
        if dist[i][i] < 0:
            has_negative_cycle = True
            break
    
    # In k·∫øt qu·∫£
    if has_negative_cycle:
        print("ƒê·ªì th·ªã c√≥ chu tr√¨nh √¢m!")
    else:
        print("Ma tr·∫≠n kho·∫£ng c√°ch:")
        for row in dist:
            print(*row)
        
        # In ƒë∆∞·ªùng ƒëi t·ª´ u ƒë·∫øn v (n·∫øu c·∫ßn)
        def get_path(u, v):
            if next_hop[u][v] == -1:
                return []
            path = [u+1]
            while u != v:
                u = next_hop[u][v]
                path.append(u+1)
            return path

# ========== BELLMAN-FORD ==========
"""
‚ùì ƒê·ªÅ b√†i: Cho ƒë·ªì th·ªã c√≥ h∆∞·ªõng N ƒë·ªânh, M c·∫°nh. M·ªói c·∫°nh c√≥ th·ªÉ c√≥ tr·ªçng s·ªë √¢m.
T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t t·ª´ ƒë·ªânh 1 v√† ki·ªÉm tra chu tr√¨nh √¢m.

üîç INPUT:
- D√≤ng 1: N M
- M d√≤ng ti·∫øp: u v w

üîé OUTPUT:
- N s·ªë: kho·∫£ng c√°ch ng·∫Øn nh·∫•t t·ª´ ƒë·ªânh 1
- C√≥ chu tr√¨nh √¢m hay kh√¥ng

üí° Ph√¢n t√≠ch:
1. C√≥ tr·ªçng s·ªë √¢m ‚Üí Bellman-Ford
2. C·∫ßn l·∫∑p N-1 l·∫ßn ƒë·ªÉ t√¨m ƒë∆∞·ªùng ng·∫Øn nh·∫•t
3. L·∫∑p th√™m 1 l·∫ßn ƒë·ªÉ ph√°t hi·ªán chu tr√¨nh √¢m
4. L∆∞u ƒë∆∞·ªùng ƒëi b·∫±ng m·∫£ng parent[]
"""

def solve_bellman_ford():
    # Nh·∫≠p d·ªØ li·ªáu
    n, m = map(int, input().split())
    edges = []
    for _ in range(m):
        u, v, w = map(int, input().split())
        edges.append((u-1, v-1, w))
    
    # Bellman-Ford
    INF = int(1e9)
    dist = [INF]*n
    parent = [-1]*n
    dist[0] = 0
    
    # L·∫∑p N-1 l·∫ßn
    for _ in range(n-1):
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                parent[v] = u
    
    # Ki·ªÉm tra chu tr√¨nh √¢m
    has_negative_cycle = False
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            has_negative_cycle = True
            break
    
    # In k·∫øt qu·∫£
    if has_negative_cycle:
        print("ƒê·ªì th·ªã c√≥ chu tr√¨nh √¢m!")
    else:
        print("Kho·∫£ng c√°ch:", *dist)
        
        # In ƒë∆∞·ªùng ƒëi t·ª´ 1 ƒë·∫øn n (n·∫øu c·∫ßn)
        if parent[n-1] != -1:
            path = []
            v = n-1
            while v != -1:
                path.append(v+1)
                v = parent[v]
            print("ƒê∆∞·ªùng ƒëi:", "->".join(map(str, reversed(path))))

# ========== BFS (ƒê·ªí TH·ªä KH√îNG TR·ªåNG S·ªê) ==========
"""
‚ùì ƒê·ªÅ b√†i: Cho ƒë·ªì th·ªã v√¥ h∆∞·ªõng N ƒë·ªânh, M c·∫°nh. T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t
t·ª´ ƒë·ªânh 1 ƒë·∫øn ƒë·ªânh N (m·ªói c·∫°nh c√≥ ƒë·ªô d√†i 1).

üîç INPUT:
- D√≤ng 1: N M
- M d√≤ng ti·∫øp: u v

üîé OUTPUT:
- Kho·∫£ng c√°ch ng·∫Øn nh·∫•t t·ª´ 1 ƒë·∫øn N
- ƒê∆∞·ªùng ƒëi (n·∫øu c√≥)

üí° Ph√¢n t√≠ch:
1. ƒê·ªì th·ªã kh√¥ng tr·ªçng s·ªë ‚Üí BFS
2. D√πng queue ƒë·ªÉ duy·ªát theo t·ª´ng l·ªõp
3. L∆∞u ƒë∆∞·ªùng ƒëi b·∫±ng m·∫£ng parent[]
4. Ki·ªÉm tra c√≥ ƒë∆∞·ªùng ƒëi hay kh√¥ng
"""

def solve_bfs():
    # Nh·∫≠p d·ªØ li·ªáu
    n, m = map(int, input().split())
    adj = [[] for _ in range(n)]
    for _ in range(m):
        u, v = map(int, input().split())
        adj[u-1].append(v-1)
        adj[v-1].append(u-1)  # V√¥ h∆∞·ªõng
    
    # BFS
    visited = [False]*n
    dist = [-1]*n
    parent = [-1]*n
    q = deque([0])  # B·∫Øt ƒë·∫ßu t·ª´ ƒë·ªânh 1 (index 0)
    visited[0] = True
    dist[0] = 0
    
    while q:
        u = q.popleft()
        for v in adj[u]:
            if not visited[v]:
                visited[v] = True
                dist[v] = dist[u] + 1
                parent[v] = u
                q.append(v)
    
    # In k·∫øt qu·∫£
    if dist[n-1] == -1:
        print("Kh√¥ng c√≥ ƒë∆∞·ªùng ƒëi!")
    else:
        print("Kho·∫£ng c√°ch:", dist[n-1])
        
        # In ƒë∆∞·ªùng ƒëi
        path = []
        v = n-1
        while v != -1:
            path.append(v+1)
            v = parent[v]
        print("ƒê∆∞·ªùng ƒëi:", "->".join(map(str, reversed(path))))

# ========== ·ª®NG D·ª§NG TH·ª∞C T·∫æ ==========
"""
1. B√†i to√°n ICPC ph·ªï bi·∫øn:
   - T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t (Dijkstra/Bellman-Ford)
   - T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t m·ªçi c·∫∑p (Floyd-Warshall)
   - Maze solver (BFS)
   - Ph√°t hi·ªán chu tr√¨nh √¢m (Bellman-Ford)
   - T·ªëi ∆∞u h√≥a m·∫°ng (Dijkstra/Floyd-Warshall)

2. ·ª®ng d·ª•ng th·ª±c t·∫ø:
   - GPS navigation (Dijkstra)
   - Network routing (Dijkstra/Floyd-Warshall)
   - Game AI pathfinding (BFS/Dijkstra)
   - Social network analysis (BFS)
   - Traffic optimization (Floyd-Warshall)
   - Currency arbitrage (Bellman-Ford)
"""

# ========== DEMO ==========
if __name__ == "__main__":
    print("\n=== Demo c√°c thu·∫≠t to√°n t√¨m ƒë∆∞·ªùng ===")
    
    print("\n1. Dijkstra:")
    test_input = """4 5
1 2 1
1 3 4
2 3 2
2 4 6
3 4 3"""
    import sys
    from io import StringIO
    sys.stdin = StringIO(test_input)
    solve_dijkstra()
    
    print("\n2. Floyd-Warshall:")
    sys.stdin = StringIO(test_input)
    solve_floyd_warshall()
    
    print("\n3. Bellman-Ford:")
    test_input = """4 5
1 2 1
1 3 4
2 3 -2
2 4 6
3 4 3"""
    sys.stdin = StringIO(test_input)
    solve_bellman_ford()
    
    print("\n4. BFS:")
    test_input = """4 4
1 2
1 3
2 4
3 4"""
    sys.stdin = StringIO(test_input)
    solve_bfs()
    
    print("\n‚úÖ ƒê√£ demo 4 thu·∫≠t to√°n t√¨m ƒë∆∞·ªùng ph·ªï bi·∫øn")
    print("üí° M·ªói thu·∫≠t to√°n ph√π h·ª£p v·ªõi m·ªôt lo·∫°i b√†i to√°n c·ª• th·ªÉ!")
