# 📚 TỔNG HỢP 4 THUẬT TOÁN TÌM ĐƯỜNG TRONG ĐỒ THỊ
# Bao gồm: Dijkstra, Floyd-Warshall, Bellman-Ford, BFS
# Mỗi thuật toán có ví dụ input và giải thích từng dòng

import heapq
from collections import deque

# ========== DIJKSTRA ==========
# Điều kiện: trọng số không âm, tìm đường đi ngắn nhất từ 1 đỉnh
# Input mẫu:
# 4 5
# 1 2 1
# 1 3 4
# 2 3 2
# 2 4 6
# 3 4 3

n, m = 4, 5
edges = [
    (1, 2, 1),
    (1, 3, 4),
    (2, 3, 2),
    (2, 4, 6),
    (3, 4, 3)
]

# Tạo ma trận trọng số ban đầu
adj = [[0]*n for _ in range(n)]
for u, v, w in edges:
    adj[u-1][v-1] = w  # có hướng

# Dijkstra từ node 0
INF = int(1e9)
dist = [INF]*n
dist[0] = 0
pq = [(0, 0)]  # (khoảng cách, node)

while pq:
    d, u = heapq.heappop(pq)
    if d > dist[u]: continue
    for v in range(n):
        if adj[u][v]:
            if dist[v] > dist[u] + adj[u][v]:
                dist[v] = dist[u] + adj[u][v]
                heapq.heappush(pq, (dist[v], v))
print("\n🔹 Dijkstra từ đỉnh 1:", dist)

# ========== FLOYD-WARSHALL ==========
# Điều kiện: đồ thị nhỏ (n ≤ 500), tìm đường đi ngắn nhất mọi cặp
fw = [[INF]*n for _ in range(n)]
for i in range(n):
    fw[i][i] = 0
for u, v, w in edges:
    fw[u-1][v-1] = w

for k in range(n):
    for i in range(n):
        for j in range(n):
            fw[i][j] = min(fw[i][j], fw[i][k] + fw[k][j])

print("\n🔹 Floyd-Warshall (mọi cặp):")
for row in fw:
    print(row)

# ========== BELLMAN-FORD ==========
# Hỗ trợ trọng số âm, tìm đường từ 1 đỉnh
bf_dist = [INF]*n
bf_dist[0] = 0

for _ in range(n-1):  # lặp n-1 lần
    for u, v, w in edges:
        u -= 1; v -= 1
        if bf_dist[u] + w < bf_dist[v]:
            bf_dist[v] = bf_dist[u] + w
print("\n🔹 Bellman-Ford từ đỉnh 1:", bf_dist)

# ========== BFS (ĐỒ THỊ KHÔNG TRỌNG SỐ) ==========
# Dùng để kiểm tra có đường đi hay không / hoặc khoảng cách đều bằng 1
# Input: danh sách kề không trọng số
g = [[], [], [], []]
g[0].append(1)
g[0].append(2)
g[1].append(3)
g[2].append(3)

visited = [False]*n
dist_bfs = [-1]*n
dist_bfs[0] = 0
q = deque([0])
visited[0] = True

while q:
    u = q.popleft()
    for v in g[u]:
        if not visited[v]:
            visited[v] = True
            dist_bfs[v] = dist_bfs[u] + 1
            q.append(v)
print("\n🔹 BFS (không trọng số) từ đỉnh 1:", dist_bfs)
