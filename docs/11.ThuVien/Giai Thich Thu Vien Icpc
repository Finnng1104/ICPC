# üìö GI·∫¢I TH√çCH CHI TI·∫æT TH∆Ø VI·ªÜN ICPC C·∫¶N D√ôNG
# ===============================================
"""
C√°c th∆∞ vi·ªán Python quan tr·ªçng trong ICPC, ƒë·∫∑c bi·ªát cho b√†i to√°n:
1. X·ª≠ l√Ω ·∫£nh v√† Computer Vision
2. H·ªçc m√°y v√† AI
3. X·ª≠ l√Ω ma tr·∫≠n v√† t√≠nh to√°n s·ªë h·ªçc
4. T·ªëi ∆∞u h√≥a hi·ªáu su·∫•t

M·ªói th∆∞ vi·ªán c√≥ ∆∞u ƒëi·ªÉm ri√™ng v√† ph√π h·ª£p v·ªõi t·ª´ng lo·∫°i b√†i to√°n c·ª• th·ªÉ.
"""

# ========== NUMPY ==========
"""
NumPy (Numerical Python):
1. M·ª•c ƒë√≠ch:
   - X·ª≠ l√Ω m·∫£ng ƒëa chi·ªÅu hi·ªáu qu·∫£
   - T√≠nh to√°n s·ªë h·ªçc nhanh
   - T·ªëi ∆∞u b·ªô nh·ªõ v√† t·ªëc ƒë·ªô

2. ·ª®ng d·ª•ng trong ICPC:
   - X·ª≠ l√Ω ma tr·∫≠n l·ªõn
   - T√≠nh to√°n vector
   - T·ªëi ∆∞u thu·∫≠t to√°n
   - X·ª≠ l√Ω d·ªØ li·ªáu ƒë·∫ßu v√†o

3. ∆Øu ƒëi·ªÉm:
   - Nhanh h∆°n list Python
   - H·ªó tr·ª£ broadcast
   - T·ªëi ∆∞u b·ªô nh·ªõ
   - Nhi·ªÅu h√†m to√°n h·ªçc
"""

import numpy as np

# 1. T·∫°o v√† thao t√°c m·∫£ng
arr = np.array([1, 2, 3, 4])
print("M·∫£ng g·ªëc:", arr)
print("C·ªông to√†n b·ªô +1:", arr + 1)  # broadcast
print("T·ªïng:", np.sum(arr))

# 2. Ma tr·∫≠n v√† t√≠nh to√°n
matrix = np.array([[1, 2], [3, 4]])
print("\nMa tr·∫≠n 2x2:")
print(matrix)
print("ƒê·ªãnh th·ª©c:", np.linalg.det(matrix))
print("Ngh·ªãch ƒë·∫£o:", np.linalg.inv(matrix))

# 3. T·ªëi ∆∞u h√≥a
# T·∫°o ma tr·∫≠n l·ªõn v√† so s√°nh v·ªõi list Python
n = 1000
np_matrix = np.zeros((n, n))  # Nhanh v√† ti·∫øt ki·ªám b·ªô nh·ªõ
print("\nT·∫°o ma tr·∫≠n", n, "x", n, "v·ªõi NumPy")

# 4. X·ª≠ l√Ω d·ªØ li·ªáu
data = np.random.rand(1000)  # T·∫°o d·ªØ li·ªáu ng·∫´u nhi√™n
print("\nTh·ªëng k√™ c∆° b·∫£n:")
print("Trung b√¨nh:", np.mean(data))
print("ƒê·ªô l·ªách chu·∫©n:", np.std(data))
print("Ph√¢n v·ªã:", np.percentile(data, [25, 50, 75]))

# ========== PILLOW (PIL) ==========
"""
Pillow (Python Imaging Library):
1. M·ª•c ƒë√≠ch:
   - X·ª≠ l√Ω ·∫£nh c∆° b·∫£n
   - Chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng
   - Thao t√°c pixel

2. ·ª®ng d·ª•ng trong ICPC:
   - ƒê·ªçc/ghi ·∫£nh
   - Resize ·∫£nh
   - Chuy·ªÉn ƒë·ªïi m√†u
   - V·∫Ω h√¨nh

3. ∆Øu ƒëi·ªÉm:
   - ƒê∆°n gi·∫£n, d·ªÖ s·ª≠ d·ª•ng
   - H·ªó tr·ª£ nhi·ªÅu ƒë·ªãnh d·∫°ng
   - T√≠ch h·ª£p t·ªët v·ªõi c√°c th∆∞ vi·ªán kh√°c
"""

from PIL import Image, ImageDraw, ImageFont

# 1. T·∫°o v√† l∆∞u ·∫£nh
img = Image.new('RGB', (100, 100), color='red')
img.save("sample.png")
print("\nüì∏ ƒê√£ t·∫°o ·∫£nh sample.png")

# 2. X·ª≠ l√Ω ·∫£nh c∆° b·∫£n
img = Image.open("sample.png")
print("K√≠ch th∆∞·ªõc:", img.size)
print("Ch·∫ø ƒë·ªô m√†u:", img.mode)

# 3. Thao t√°c ·∫£nh
img_resized = img.resize((50, 50))
img_rotated = img.rotate(45)
img_flipped = img.transpose(Image.FLIP_LEFT_RIGHT)

# 4. V·∫Ω tr√™n ·∫£nh
draw = ImageDraw.Draw(img)
draw.rectangle([(20, 20), (80, 80)], outline='blue', width=2)
draw.text((40, 40), "Hello", fill='white')
img.save("sample_drawn.png")

# ========== OPENCV (cv2) ==========
"""
OpenCV (Open Source Computer Vision):
1. M·ª•c ƒë√≠ch:
   - X·ª≠ l√Ω ·∫£nh n√¢ng cao
   - Computer Vision
   - Nh·∫≠n di·ªán ƒë·ªëi t∆∞·ª£ng
   - X·ª≠ l√Ω video

2. ·ª®ng d·ª•ng trong ICPC:
   - X·ª≠ l√Ω ·∫£nh ph·ª©c t·∫°p
   - T√¨m contour, edge
   - Nh·∫≠n di·ªán m·∫´u
   - Ph√¢n ƒëo·∫°n ·∫£nh

3. ∆Øu ƒëi·ªÉm:
   - Hi·ªáu su·∫•t cao
   - Nhi·ªÅu thu·∫≠t to√°n c√≥ s·∫µn
   - T√≠ch h·ª£p AI
   - X·ª≠ l√Ω realtime
"""

import cv2
import numpy as np

# 1. ƒê·ªçc v√† x·ª≠ l√Ω ·∫£nh
img_cv = cv2.imread("sample.png")
gray = cv2.cvtColor(img_cv, cv2.COLOR_BGR2GRAY)
print("\nüß™ X·ª≠ l√Ω ·∫£nh v·ªõi OpenCV")
print("K√≠ch th∆∞·ªõc ·∫£nh:", img_cv.shape)

# 2. L·ªçc v√† bi·∫øn ƒë·ªïi
# Gaussian blur
blurred = cv2.GaussianBlur(gray, (5, 5), 0)
# Canny edge detection
edges = cv2.Canny(blurred, 100, 200)
# Threshold
_, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

# 3. T√¨m contour
contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
print("S·ªë contour t√¨m ƒë∆∞·ª£c:", len(contours))

# 4. V·∫Ω k·∫øt qu·∫£
cv2.drawContours(img_cv, contours, -1, (0, 255, 0), 2)
cv2.imwrite("processed.png", img_cv)

# ========== TORCH (PyTorch) ==========
"""
PyTorch:
1. M·ª•c ƒë√≠ch:
   - Deep Learning
   - X·ª≠ l√Ω tensor
   - Hu·∫•n luy·ªán m√¥ h√¨nh
   - Inference

2. ·ª®ng d·ª•ng trong ICPC:
   - Nh·∫≠n di·ªán ƒë·ªëi t∆∞·ª£ng
   - Ph√¢n lo·∫°i ·∫£nh
   - X·ª≠ l√Ω ng√¥n ng·ªØ
   - T·ªëi ∆∞u h√≥a

3. ∆Øu ƒëi·ªÉm:
   - T√≠nh to√°n GPU
   - Dynamic computation
   - D·ªÖ debug
   - C·ªông ƒë·ªìng l·ªõn
"""

import torch
import torch.nn as nn
import torch.optim as optim

# 1. T·∫°o v√† thao t√°c tensor
x = torch.tensor([1.0, 2.0, 3.0])
print("\nüî• PyTorch Tensor Operations")
print("Tensor ban ƒë·∫ßu:", x)
print("B√¨nh ph∆∞∆°ng:", x ** 2)
print("T·ªïng:", x.sum())

# 2. T·∫°o m√¥ h√¨nh ƒë∆°n gi·∫£n
class SimpleNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.layer1 = nn.Linear(10, 5)
        self.layer2 = nn.Linear(5, 1)
    
    def forward(self, x):
        x = torch.relu(self.layer1(x))
        return self.layer2(x)

# 3. T·∫°o d·ªØ li·ªáu v√† hu·∫•n luy·ªán
model = SimpleNN()
criterion = nn.MSELoss()
optimizer = optim.SGD(model.parameters(), lr=0.01)

# 4. Inference
model.eval()
with torch.no_grad():
    test_input = torch.randn(1, 10)
    prediction = model(test_input)
    print("\nD·ª± ƒëo√°n m·∫´u:", prediction.item())

# ========== TORCHVISION ==========
"""
TorchVision:
1. M·ª•c ƒë√≠ch:
   - Dataset v√† DataLoader
   - Transform ·∫£nh
   - M√¥ h√¨nh pretrained
   - Utilities

2. ·ª®ng d·ª•ng trong ICPC:
   - Load dataset
   - Ti·ªÅn x·ª≠ l√Ω ·∫£nh
   - Transfer learning
   - Model evaluation

3. ∆Øu ƒëi·ªÉm:
   - T√≠ch h·ª£p PyTorch
   - Nhi·ªÅu m√¥ h√¨nh c√≥ s·∫µn
   - Transform chu·∫©n
   - D·ªÖ s·ª≠ d·ª•ng
"""

import torchvision.transforms as transforms
from torchvision import models, datasets

# 1. Transform ·∫£nh
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                       std=[0.229, 0.224, 0.225])
])

# 2. Load m√¥ h√¨nh pretrained
model = models.resnet18(pretrained=True)
model.eval()
print("\n‚úÖ ƒê√£ t·∫£i m√¥ h√¨nh ResNet18")

# 3. Dataset v√† DataLoader
# dataset = datasets.ImageFolder('path/to/data', transform=transform)
# dataloader = torch.utils.data.DataLoader(dataset, batch_size=32)

# ========== T·ªîNG K·∫æT & ·ª®NG D·ª§NG ==========
"""
1. B√†i to√°n ICPC ph·ªï bi·∫øn:
   - X·ª≠ l√Ω ·∫£nh: OpenCV + NumPy
   - AI/ML: PyTorch + TorchVision
   - T√≠nh to√°n ma tr·∫≠n: NumPy
   - ƒê·ªçc/ghi file: PIL

2. ·ª®ng d·ª•ng th·ª±c t·∫ø:
   - Computer Vision: OpenCV
   - Deep Learning: PyTorch
   - Data Science: NumPy
   - Image Processing: PIL

3. Tips khi s·ª≠ d·ª•ng:
   - Ch·ªçn th∆∞ vi·ªán ph√π h·ª£p v·ªõi b√†i to√°n
   - T·ªëi ∆∞u b·ªô nh·ªõ v√† t·ªëc ƒë·ªô
   - X·ª≠ l√Ω l·ªói v√† ngo·∫°i l·ªá
   - Ki·ªÉm tra k·∫øt qu·∫£
"""

print("\n‚úÖ T√≥m t·∫Øt c√°c th∆∞ vi·ªán:")
print("- numpy:    X·ª≠ l√Ω m·∫£ng s·ªë h·ªçc nhanh, t·ªëi ∆∞u b·ªô nh·ªõ")
print("- pillow:   X·ª≠ l√Ω ·∫£nh c∆° b·∫£n, ƒë∆°n gi·∫£n v√† d·ªÖ s·ª≠ d·ª•ng")
print("- opencv:   X·ª≠ l√Ω ·∫£nh n√¢ng cao, computer vision")
print("- torch:    Deep learning, t√≠nh to√°n tensor hi·ªáu qu·∫£")
print("- torchvision: Model pretrained, transform ·∫£nh chu·∫©n")

print("\nüí° L∆∞u √Ω khi s·ª≠ d·ª•ng:")
print("1. C√†i ƒë·∫∑t ƒë√∫ng phi√™n b·∫£n t∆∞∆°ng th√≠ch")
print("2. Ki·ªÉm tra t√†i li·ªáu v√† v√≠ d·ª•")
print("3. T·ªëi ∆∞u code cho t·ª´ng th∆∞ vi·ªán")
print("4. X·ª≠ l√Ω l·ªói v√† ngo·∫°i l·ªá")
print("5. Test k·ªπ tr∆∞·ªõc khi submit")
